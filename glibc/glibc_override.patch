diff --git a/sysdeps/unix/sysv/linux/close.c b/sysdeps/unix/sysv/linux/close.c
index a7a02959a0..d8ddf1f1c3 100644
--- a/sysdeps/unix/sysv/linux/close.c
+++ b/sysdeps/unix/sysv/linux/close.c
@@ -20,11 +20,26 @@
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
 
+/*
+ * vectored overrides for the close() system call
+ *
+ */
+
+ typedef int (*vt_close_t)(int);
+ static int wclose(int fd);
+ static vt_close_t  vt_close  = wclose;
+ static int wclose(int fd)
+    { return SYSCALL_CANCEL (close, fd); }
+ static int vclose(int fd)
+    { return (*vt_close)(fd); }
+ void ovr_close(vt_close_t nfp, vt_close_t* ofp)
+    { *ofp = vt_close; vt_close = nfp; }
+
 /* Close the file descriptor FD.  */
 int
 __close (int fd)
 {
-  return SYSCALL_CANCEL (close, fd);
+  return vclose(fd);
 }
 libc_hidden_def (__close)
 strong_alias (__close, __libc_close)
diff --git a/sysdeps/unix/sysv/linux/generic/unlink.c b/sysdeps/unix/sysv/linux/generic/unlink.c
index 80fa3eb0c0..23dd0b17de 100644
--- a/sysdeps/unix/sysv/linux/generic/unlink.c
+++ b/sysdeps/unix/sysv/linux/generic/unlink.c
@@ -21,11 +21,24 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+/*
+ * vectored overrides for the unlink() system call
+ *
+ */
+typedef int (*vt_unlink_t)(const char*);
+static int wunlink(const char* pathname);
+static vt_unlink_t vt_unlink = wunlink;
+static int wunlink(const char* pathname)
+    { return INLINE_SYSCALL (unlinkat, 3, AT_FDCWD, pathname, 0); }
+static int vunlink(const char* pathname)
+    { return (*vt_unlink)(pathname); }
+void ovr_unlink(vt_unlink_t nfp, vt_unlink_t* ofp)
+    { *ofp = vt_unlink; vt_unlink = nfp; }
 
 /* Remove the link named NAME.  */
 int
 __unlink (const char *name)
 {
-  return INLINE_SYSCALL (unlinkat, 3, AT_FDCWD, name, 0);
+  return vunlink(name);
 }
 weak_alias (__unlink, unlink)
diff --git a/sysdeps/unix/sysv/linux/lseek.c b/sysdeps/unix/sysv/linux/lseek.c
index 6d17d0e667..904ae385da 100644
--- a/sysdeps/unix/sysv/linux/lseek.c
+++ b/sysdeps/unix/sysv/linux/lseek.c
@@ -24,6 +24,23 @@
 
 #ifndef __OFF_T_MATCHES_OFF64_T
 
+/*
+ * vectored overrides for the lseek() system call
+ *
+ * Note we don't expose an override for _llseek().
+ *
+ */
+
+typedef off_t   (*vt_lseek_t)(int, off_t, int);
+static off_t wlseek(int fd, off_t offset, int whence);
+static vt_lseek_t  vt_lseek  = wlseek;
+static off_t wlseek(int fd, off_t offset, int whence)
+    { return INLINE_SYSCALL_CALL (lseek, fd, offset, whence); }
+static off_t vlseek(int fd, off_t offset, int whence)
+    { return (*vt_lseek)(fd, offset, whence); }
+void ovr_lseek(vt_lseek_t nfp, vt_lseek_t* ofp)
+    { *ofp = vt_lseek; vt_lseek = nfp; }
+
 /* Test for overflows of structures where we ask the kernel to fill them
    in with standard 64-bit syscalls but return them through APIs that
    only expose the low 32 bits of some fields.  */
@@ -48,7 +65,7 @@ __lseek (int fd, off_t offset, int whence)
 				(long) offset, &res, whence);
   return rc ?: lseek_overflow (res);
 # else
-  return INLINE_SYSCALL_CALL (lseek, fd, offset, whence);
+  return vlseek(fd, offset, whence);
 # endif
 }
 libc_hidden_def (__lseek)
diff --git a/sysdeps/unix/sysv/linux/lseek64.c b/sysdeps/unix/sysv/linux/lseek64.c
index ecf4338cdb..a010a74851 100644
--- a/sysdeps/unix/sysv/linux/lseek64.c
+++ b/sysdeps/unix/sysv/linux/lseek64.c
@@ -23,6 +23,23 @@
 #include <errno.h>
 #include <shlib-compat.h>
 
+/*
+ * vectored overrides for the lseek() system call
+ *
+ * Note we don't expose an override for _llseek().
+ *
+ */
+
+typedef off_t   (*vt_lseek_t)(int, off_t, int);
+static off_t wlseek(int fd, off_t offset, int whence);
+static vt_lseek_t  vt_lseek  = wlseek;
+static off_t wlseek(int fd, off_t offset, int whence)
+    { return INLINE_SYSCALL_CALL (lseek, fd, offset, whence); }
+static off_t vlseek(int fd, off_t offset, int whence)
+    { return (*vt_lseek)(fd, offset, whence); }
+void ovr_lseek(vt_lseek_t nfp, vt_lseek_t* ofp)
+    { *ofp = vt_lseek; vt_lseek = nfp; }
+
 off64_t
 __lseek64 (int fd, off64_t offset, int whence)
 {
@@ -33,7 +50,7 @@ __lseek64 (int fd, off64_t offset, int whence)
 				(long) offset, &res, whence);
   return rc ?: res;
 #else
-  return INLINE_SYSCALL_CALL (lseek, fd, offset, whence);
+  return vlseek(fd, offset, whence);
 #endif
 }
 
diff --git a/sysdeps/unix/sysv/linux/open.c b/sysdeps/unix/sysv/linux/open.c
index 3782ae8620..6adbcf8405 100644
--- a/sysdeps/unix/sysv/linux/open.c
+++ b/sysdeps/unix/sysv/linux/open.c
@@ -26,6 +26,21 @@
 
 #ifndef __OFF_T_MATCHES_OFF64_T
 
+/*
+ * vectored overrides for the open() system call
+ *
+ */
+
+ typedef int (*vt_open_t)(const char*, int, int);
+ static int wopen(const char* pathname, int flags, int perm);
+ static vt_open_t   vt_open   = wopen;
+ static int wopen(const char* pathname, int flags, int perm)
+     { return SYSCALL_CANCEL (openat, AT_FDCWD, pathname, flags, perm); }
+ static int vopen(const char* pathname, int flags, int perm)
+     { return (*vt_open)(pathname, flags, perm); }
+ void ovr_open(vt_open_t nfp, vt_open_t* ofp)
+     { *ofp = vt_open; vt_open = nfp; }
+
 /* Open FILE with access OFLAG.  If O_CREAT or O_TMPFILE is in OFLAG,
    a third argument is the file protection.  */
 int
@@ -41,7 +56,7 @@ __libc_open (const char *file, int oflag, ...)
       va_end (arg);
     }
 
-  return SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag, mode);
+  return vopen(file, oflag, mode);
 }
 libc_hidden_def (__libc_open)
 
diff --git a/sysdeps/unix/sysv/linux/open64.c b/sysdeps/unix/sysv/linux/open64.c
index 2c4e82950f..82cd68bdb7 100644
--- a/sysdeps/unix/sysv/linux/open64.c
+++ b/sysdeps/unix/sysv/linux/open64.c
@@ -30,6 +30,21 @@
 # define EXTRA_OPEN_FLAGS O_LARGEFILE
 #endif
 
+/*
+ * vectored overrides for the open() system call
+ *
+ */
+
+ typedef int (*vt_open_t)(const char*, int, int);
+ static int wopen(const char* pathname, int flags, int perm);
+ static vt_open_t   vt_open   = wopen;
+ static int wopen(const char* pathname, int flags, int perm)
+     { return SYSCALL_CANCEL (openat, AT_FDCWD, pathname, flags, perm); }
+ static int vopen(const char* pathname, int flags, int perm)
+     { return (*vt_open)(pathname, flags, perm); }
+ void ovr_open(vt_open_t nfp, vt_open_t* ofp)
+     { *ofp = vt_open; vt_open = nfp; }
+
 /* Open FILE with access OFLAG.  If O_CREAT or O_TMPFILE is in OFLAG,
    a third argument is the file protection.  */
 int
@@ -45,8 +60,7 @@ __libc_open64 (const char *file, int oflag, ...)
       va_end (arg);
     }
 
-  return SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,
-			 mode);
+  return vopen(file, oflag | EXTRA_OPEN_FLAGS, mode);
 }
 
 strong_alias (__libc_open64, __open64)
diff --git a/sysdeps/unix/sysv/linux/read.c b/sysdeps/unix/sysv/linux/read.c
index 13f5912156..a6b084af91 100644
--- a/sysdeps/unix/sysv/linux/read.c
+++ b/sysdeps/unix/sysv/linux/read.c
@@ -19,11 +19,26 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 
+/*
+ * vectored overrides for the read() system call
+ *
+ */
+
+typedef ssize_t (*vt_read_t)(int, void*, size_t);
+static ssize_t wread(int fd, void* buff, size_t count);
+static vt_read_t vt_read   = wread;
+static ssize_t wread(int fd, void* buff, size_t count)
+    { return SYSCALL_CANCEL (read, fd, buff, count); }
+static ssize_t vread(int fd, void* buff, size_t count)
+    { return (*vt_read)(fd, buff, count); }
+void ovr_read(vt_read_t nfp, vt_read_t* ofp)
+    { *ofp = vt_read; vt_read = nfp; }
+
 /* Read NBYTES into BUF from FD.  Return the number read or -1.  */
 ssize_t
 __libc_read (int fd, void *buf, size_t nbytes)
 {
-  return SYSCALL_CANCEL (read, fd, buf, nbytes);
+  return vread(fd, buf, nbytes);
 }
 libc_hidden_def (__libc_read)
 
diff --git a/sysdeps/unix/sysv/linux/write.c b/sysdeps/unix/sysv/linux/write.c
index 76bc14afd7..cb2c400adc 100644
--- a/sysdeps/unix/sysv/linux/write.c
+++ b/sysdeps/unix/sysv/linux/write.c
@@ -19,11 +19,26 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 
+/*
+ * Vectored override for the write() system call.
+ *
+ */
+
+ typedef ssize_t (*vt_write_t)(int, const void*, size_t);
+ static ssize_t wwrite(int fd, const void* buff, size_t count);
+ static vt_write_t  vt_write  = wwrite;
+ static ssize_t wwrite(int fd, const void* buff, size_t count)
+     { return SYSCALL_CANCEL (write, fd, buff, count); }
+ static ssize_t vwrite(int fd, const void* buff, size_t count)
+     { return (*vt_write)(fd, buff, count); }
+ void ovr_write(vt_write_t nfp, vt_write_t* ofp)
+     { *ofp = vt_write; vt_write = nfp; }
+
 /* Write NBYTES of BUF to FD.  Return the number written, or -1.  */
 ssize_t
 __libc_write (int fd, const void *buf, size_t nbytes)
 {
-  return SYSCALL_CANCEL (write, fd, buf, nbytes);
+  return vwrite(fd, buf, nbytes);
 }
 libc_hidden_def (__libc_write)
 
